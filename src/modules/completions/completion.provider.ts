import * as vscode from 'vscode';
import { Injectable } from '@nestjs/common';
import { OllamaService } from '../ollama/ollama.service';
import { LoggingService } from '../logging/logging.service';

@Injectable()
export class CompletionProvider implements vscode.CompletionItemProvider {
  private debounceTimeout: NodeJS.Timeout | null = null;
  private readonly debounceDelay = 300; // ms
  private completionCache: Map<string, string> = new Map();

  constructor(
    private readonly ollamaService: OllamaService,
    private readonly loggingService: LoggingService,
  ) {}

  async provideCompletionItems(
    document: vscode.TextDocument,
    position: vscode.Position,
    token: vscode.CancellationToken,
  ): Promise<vscode.CompletionItem[]> {
    if (token.isCancellationRequested) {
      return [];
    }

    // Get broader context: up to 10 lines before the cursor
    const range = new vscode.Range(
      Math.max(0, position.line - 10),
      0,
      position.line,
      position.character,
    );
    const prompt = document.getText(range).trim();
    if (!prompt || !this.isValidTrigger(document, position)) {
      return [];
    }

    // Check cache first
    if (this.completionCache.has(prompt)) {
      return this.createCompletionItems(this.completionCache.get(prompt)!);
    }

    try {
      // Debounced AI call
      const completion = await this.getCompletionWithDebounce(prompt, token);
      if (!completion) {
        return [];
      }

      // Cache the result
      this.completionCache.set(prompt, completion);
      if (this.completionCache.size > 50) {
        this.clearOldCacheEntries();
      }

      return this.createCompletionItems(completion);
    } catch (error) {
      this.loggingService.logError('Completion error');
      return [];
    }
  }

  private isValidTrigger(document: vscode.TextDocument, position: vscode.Position): boolean {
    const line = document.lineAt(position.line).text.substring(0, position.character);
    // Trigger only after '.', '(', or relevant keywords
    const triggerChars = ['.', '('];
    const lastChar = line.trim().slice(-1);
    return triggerChars.includes(lastChar) || /\b(function|class|const|let|var)\s+$/.test(line);
  }

  private async getCompletionWithDebounce(prompt: string, token: vscode.CancellationToken): Promise<string | null> {
    return new Promise((resolve, reject) => {
      if (this.debounceTimeout) {
        clearTimeout(this.debounceTimeout);
      }
  
      this.debounceTimeout = setTimeout(async () => {
        if (token.isCancellationRequested) {
          resolve(null);
          return;
        }
  
        try {
          const model = await this.ollamaService.getDefaultModel()
          const completion = await this.ollamaService.getCompletion(prompt, model ?? "");
          resolve(completion);
        } catch (error) {
          this.loggingService.logError('Failed to fetch completion');
          resolve(null);
        }
      }, this.debounceDelay);
    });
  }
  
  private createCompletionItems(completion: string): vscode.CompletionItem[] {
    const lines = completion.split('\n').filter((line) => line.trim());
    const isMultiLine = lines.length > 1;
  
    const item = new vscode.CompletionItem(
      completion,
      isMultiLine ? vscode.CompletionItemKind.Snippet : vscode.CompletionItemKind.Text,
    );
    item.kind = vscode.CompletionItemKind.Keyword;
    item.detail = 'Generated by DeepSeek';
    item.documentation = new vscode.MarkdownString('AI-generated suggestion based on context.');
  
    if (isMultiLine) {
      // Format multi-line completions as a snippet
      item.insertText = new vscode.SnippetString(completion);
    } else {
      item.insertText = completion;
    }
  
    return [item];
  }
  
  private clearOldCacheEntries() {
    // Keep the cache size manageable by removing oldest entries
    const entries = Array.from(this.completionCache.entries());
    if (entries.length > 50) {
      const toRemove = entries.slice(0, entries.length - 50);
      toRemove.forEach(([key]) => this.completionCache.delete(key));
    }
  }
  
  // Optional: Resolve completion item (e.g., for additional info or adjustments)
  resolveCompletionItem(
    item: vscode.CompletionItem,
    token: vscode.CancellationToken,
  ): vscode.CompletionItem | Thenable<vscode.CompletionItem> {
    return item; // Can be extended for additional processing if needed
  }
  }
  